[{"title":"Niannings","url":"https://niannings.github.io/2020/10/11/hello-world/","content":"<p>初始化</p>\n","categories":[],"tags":[]},{"title":"javascript调用栈","url":"https://niannings.github.io/2019/10/24/javascript调用栈/","content":"<p>调用栈是解释器（就像浏览器中的JavaScript解释器）追踪函数执行流的一种机制。当执行环境中调用了多个函数函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。</p>\n<h3 id=\"问题引入\"><a href=\"#问题引入\" class=\"headerlink\" title=\"问题引入\"></a>问题引入</h3><ul>\n<li>函数是如何执行的？</li>\n<li>多个函数执行时如何追踪当前执行的函数？</li>\n</ul>\n<p><strong>一段代码：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeting</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// [1] Some codes here</span></span><br><span class=\"line\">   sayHi();</span><br><span class=\"line\">   <span class=\"comment\">// [2] Some codes here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hi!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 `greeting` 函数</span></span><br><span class=\"line\">greeting();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [3] Some codes here</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>看看调用栈的工作流程：</strong></p>\n<ul>\n<li>每调用一个函数，解释器就会把该函数添加进调用栈并开始执行。</li>\n<li>正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。</li>\n<li>当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。</li>\n<li>当分配的调用栈空间被占满时，会引发“堆栈溢出”。</li>\n</ul>\n<p><strong>回头看前面函数的执行过程：</strong></p>\n<ol>\n<li>greeting()函数被调用。</li>\n<li>把greeting()添加进调用栈列表。</li>\n<li>执行greeting()函数体中的所有代码。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">调用栈列表:</span><br><span class=\"line\">- greeting</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>代码执行到sayHi()时，该函数被调用。</li>\n<li>把sayHi()添加进调用栈列表。</li>\n<li>执行sayHi()函数体中的代码，直到全部执行完毕。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">调用栈列表:</span><br><span class=\"line\">- greeting</span><br><span class=\"line\">- sayHi</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>返回来继续执行greeting()函数体中sayHi()后面的代码。</li>\n<li>删除调用栈列表中的sayHi()函数。</li>\n<li>当greeting()函数体中的代码全部执行完毕，返回到调用greeting()的代码行，继续执行剩余JS代码。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">调用栈列表:</span><br><span class=\"line\">- greeting</span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li>删除调用栈列表中的greeting()函数。</li>\n</ol>\n","categories":[],"tags":["基础"]},{"title":"javascript数值","url":"https://niannings.github.io/2019/10/24/javascript数值/","content":"<h1 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h1><h2 id=\"整数和浮点数\"><a href=\"#整数和浮点数\" class=\"headerlink\" title=\"整数和浮点数\"></a>整数和浮点数</h2><ul>\n<li>JavaScript的数字都是64位双精度浮点数</li>\n</ul>\n<h2 id=\"精度问题\"><a href=\"#精度问题\" class=\"headerlink\" title=\"精度问题\"></a>精度问题</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> === <span class=\"number\">0.3</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p><em>根据国际标准 IEEE 754</em>，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的:</p>\n<ul>\n<li>第1位：符号位，0表示正数，1表示负数</li>\n<li>第2位到第12位（共11位）：指数部分</li>\n<li>第13位到第64位（共52位）：小数部分（即有效数字）<br>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</li>\n</ul>\n<p>指数11个二进制位，因此大小范围是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(-1)^符号位 * 1.xx...xx * 2^指数部分</span><br></pre></td></tr></table></figure>\n\n<p>上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。</p>\n<p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-2^53到2^53，都可以精确表示。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>)</span><br><span class=\"line\"><span class=\"comment\">// 9007199254740992</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// 9007199254740992</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) + <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// 9007199254740994</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) + <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"comment\">// 9007199254740996</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) + <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"comment\">// 9007199254740996</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 超过有效数字部分将无法保存，直接转换成0</span></span><br><span class=\"line\"><span class=\"number\">9007199254740996111</span> <span class=\"comment\">// 输入</span></span><br><span class=\"line\"><span class=\"number\">9007199254740996000</span> <span class=\"comment\">// 输出</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数值范围\"><a href=\"#数值范围\" class=\"headerlink\" title=\"数值范围\"></a>数值范围</h2><blockquote>\n<p>根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。</p>\n</blockquote>\n<p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">1024</span>) <span class=\"comment\">// Infinity</span></span><br></pre></td></tr></table></figure>\n\n<p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">-1075</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.MAX_VALUE <span class=\"comment\">// 1.7976931348623157e+308</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.MIN_VALUE <span class=\"comment\">// 5e-324</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"科学计数法\"><a href=\"#科学计数法\" class=\"headerlink\" title=\"科学计数法\"></a>科学计数法</h2><p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。</p>\n<ol>\n<li>小数点前的数字多于21位。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1234567890123456789012</span></span><br><span class=\"line\"><span class=\"comment\">// 1.2345678901234568e+21</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">123456789012345678901</span></span><br><span class=\"line\"><span class=\"comment\">// 123456789012345680000</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>小数点后的零多于5个。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 小数点后紧跟5个以上的零，</span></span><br><span class=\"line\"><span class=\"comment\">// 就自动转为科学计数法</span></span><br><span class=\"line\"><span class=\"number\">0.0000003</span> <span class=\"comment\">// 3e-7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 否则，就保持原来的字面形式</span></span><br><span class=\"line\"><span class=\"number\">0.000003</span> <span class=\"comment\">// 0.000003</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"与数值相关的全局方法\"><a href=\"#与数值相关的全局方法\" class=\"headerlink\" title=\"与数值相关的全局方法\"></a>与数值相关的全局方法</h2><h3 id=\"parseInt\"><a href=\"#parseInt\" class=\"headerlink\" title=\"parseInt()\"></a>parseInt()</h3><p>parseInt方法用于将字符串转为整数。</p>\n<ul>\n<li>如果字符串头部有空格，空格会被自动去除。</li>\n<li>如果parseInt的参数不是字符串，则会先转为字符串再转换。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"number\">1.23</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;1.23&#x27;</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符串转为整数的时候，是<strong>一个个字符依次转换</strong>，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;12abc&#x27;</span>) <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。</li>\n<li>如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;0xff&#x27;</span>) <span class=\"comment\">// 255</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里整数部分有22位，超过了21位</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"number\">1000000000000000000000.1</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 相当于</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;1e+21&#x27;</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 控制台</span></span><br><span class=\"line\"><span class=\"number\">1000000000000000000000.1</span> <span class=\"comment\">// 输入</span></span><br><span class=\"line\"><span class=\"number\">1e+21</span> <span class=\"comment\">// 输出</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseInt-用于进制转换\"><a href=\"#parseInt-用于进制转换\" class=\"headerlink\" title=\"parseInt()用于进制转换\"></a>parseInt()用于进制转换</h3><ul>\n<li>parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseInt</span>(<span class=\"params\">str: <span class=\"built_in\">string</span>, decimal: <span class=\"built_in\">number</span> = 10</span>): <span class=\"title\">number</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1000的二进制转化成十进制是 8</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;1000&#x27;</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 8</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;1000&#x27;</span>, <span class=\"number\">6</span>) <span class=\"comment\">// 216</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;1000&#x27;</span>, <span class=\"number\">8</span>) <span class=\"comment\">// 512</span></span><br><span class=\"line\"><span class=\"comment\">// 超过36</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;10&#x27;</span>, <span class=\"number\">37</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;10&#x27;</span>, <span class=\"number\">1</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;10&#x27;</span>, <span class=\"number\">0</span>) <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;10&#x27;</span>, <span class=\"literal\">null</span>) <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;10&#x27;</span>, <span class=\"literal\">undefined</span>) <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二进制没有5 4 6，因此只取了已经转换的值</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;1546&#x27;</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;546&#x27;</span>, <span class=\"number\">2</span>) <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"number\">0x11</span>, <span class=\"number\">36</span>) <span class=\"comment\">// 43</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"number\">0x11</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"built_in\">String</span>(<span class=\"number\">0x11</span>), <span class=\"number\">36</span>)</span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"built_in\">String</span>(<span class=\"number\">0x11</span>), <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"comment\">// 十六进制的0x11会被先转为十进制的17，再转为字符串</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;17&#x27;</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;17&#x27;</span>, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于八进制</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"number\">011</span>, <span class=\"number\">2</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"built_in\">String</span>(<span class=\"number\">011</span>), <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"built_in\">String</span>(<span class=\"number\">9</span>), <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong>：JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p>\n</blockquote>\n<ul>\n<li>总结</li>\n</ul>\n<p>parseInt的第一个参数无论如何都会先转换为十进制表示法，再转换为字符串，最后将该字符串转换为十进制。</p>\n<h2 id=\"parseFloat\"><a href=\"#parseFloat\" class=\"headerlink\" title=\"parseFloat()\"></a>parseFloat()</h2><h2 id=\"isNaN\"><a href=\"#isNaN\" class=\"headerlink\" title=\"isNaN()\"></a>isNaN()</h2><h2 id=\"isFinite\"><a href=\"#isFinite\" class=\"headerlink\" title=\"isFinite()\"></a>isFinite()</h2><p>isFinite方法返回一个布尔值，表示某个值<strong>是否为正常的数值</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"literal\">Infinity</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(-<span class=\"literal\">Infinity</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"literal\">NaN</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"literal\">undefined</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"literal\">null</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"number\">-1</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://wangdoc.com/javascript/types/number.html\">JavaScript 标准参考教程(基本语法之数值) —— 阮一峰</a></p>\n","categories":[],"tags":["基础"]},{"title":"per-vue-project","url":"https://niannings.github.io/2019/10/18/per-vue-project/","content":"<h1 id=\"Vue项目优化实践\"><a href=\"#Vue项目优化实践\" class=\"headerlink\" title=\"Vue项目优化实践\"></a>Vue项目优化实践</h1><h2 id=\"工具函数导入方式优化\"><a href=\"#工具函数导入方式优化\" class=\"headerlink\" title=\"工具函数导入方式优化\"></a>工具函数导入方式优化</h2><p>例如公共的格式化类工具函数，要使用它们首先要引入，然后还要把它们一个个挂到组件实例上才能被模版使用，非常不方便，例如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// formatter.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatDate</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 此处省略大量...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sth.vue</span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; formatDate, ...大量函数 &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;formatter&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        formatDate,</span><br><span class=\"line\">        ...大量函数</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>通过 <code>mixin</code>解决：将所有的<code>format</code>函数放到<code>mixin</code>里，使用时直接<code>mixin</code>混入。<br>优点：避免了繁琐的引入<br>缺点：方法使用时来路不明，大量冗余方法挂载到实例上<br>不可取。</p>\n</li>\n<li><p>借鉴<code>vuex</code>的<code>mapGetter</code>方式：</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// utils/tools</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pick</span>(<span class=\"params\">obj, keys = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> keys.reduce(<span class=\"function\">(<span class=\"params\">o, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!obj[key]) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">`pick error: 不存在<span class=\"subst\">$&#123;key&#125;</span>～`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    o[key] = obj[key]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> o</span><br><span class=\"line\">  &#125;, &#123;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> config <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./formatters&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; pick &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;utils/tools&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./formatters&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, config)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 由于ElementUI表格上的formatter函数参数顺序问题，这里调整参数顺序</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.entries(config).forEach(<span class=\"function\">(<span class=\"params\">[key, fn]</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  obj[<span class=\"string\">`_<span class=\"subst\">$&#123;key&#125;</span>`</span>] = <span class=\"function\">(<span class=\"params\">row, column, value, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn(value, <span class=\"literal\">undefined</span>, index, row, column)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapFormatters</span>(<span class=\"params\">keys = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pick(obj, keys)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时组件内部就可以这样使用：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sth.vue</span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapformatters &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;formatter&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        ...mapformatters([</span><br><span class=\"line\">            <span class=\"string\">&#x27;formatDate&#x27;</span>,</span><br><span class=\"line\">            ...大量函数名称</span><br><span class=\"line\">        ])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"接口调用方面\"><a href=\"#接口调用方面\" class=\"headerlink\" title=\"接口调用方面\"></a>接口调用方面</h2><h3 id=\"Promise-or-async-await\"><a href=\"#Promise-or-async-await\" class=\"headerlink\" title=\"Promise or async/await\"></a>Promise or async/await</h3><ul>\n<li>只有一个请求使用<code>promise</code>即可，多个请求嵌套时使用<code>async/await</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 嵌套 */</span></span><br><span class=\"line\"><span class=\"comment\">// promise</span></span><br><span class=\"line\">a(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  b(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    c()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// async/await</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> a()</span><br><span class=\"line\"><span class=\"keyword\">await</span> b()</span><br><span class=\"line\"><span class=\"keyword\">await</span> c()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>但是如果有两个并发的异步请求，在都完成后do something：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//错误</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> a()</span><br><span class=\"line\"><span class=\"keyword\">await</span> b()</span><br><span class=\"line\"><span class=\"comment\">//这样变成了 a().then(() =&gt; b() )</span></span><br><span class=\"line\"><span class=\"comment\">// a 好了才会执行 b</span></span><br><span class=\"line\">done()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//正确</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([a(), b()])</span><br><span class=\"line\">done()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"命名方面\"><a href=\"#命名方面\" class=\"headerlink\" title=\"命名方面\"></a>命名方面</h2><p>参考Vue官方<a href=\"https://cn.vuejs.org/v2/style-guide/index.html\">风格指南</a></p>\n<ul>\n<li>单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。</li>\n<li>组件名为多个单词必要<br>组件名应该始终是多个单词的：<br>根组件 <code>App</code> 以及 <code>&lt;transition&gt;、&lt;component&gt;</code> 之类的 <code>Vue</code> 内置组件除外。<br>这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</li>\n</ul>\n<h2 id=\"Watch-immediate\"><a href=\"#Watch-immediate\" class=\"headerlink\" title=\"Watch immediate\"></a>Watch immediate</h2><p>当 watch 一个变量的时候，初始化时并不会执行，如下面的例子，你需要在created的时候手动调用一次。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    created() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.checkedMap = &#123;...this.defaultFilters&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    watch: &#123;</span><br><span class=\"line\">        defaultFilters () &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.checkedMap = &#123;...this.defaultFilters&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    watch: &#123;</span><br><span class=\"line\">        defaultFilters: &#123;</span><br><span class=\"line\">            handler: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.checkedMap = &#123;...this.defaultFilters&#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            immediate: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>::: tip<br>ps: watch 还有一个容易被大家忽略的属性deep。当设置为true时，它会进行深度监听。简而言之就是你有一个 const obj={a:1,b:2}，里面任意一个 key 的 value 发生变化的时候都会触发watch。应用场景：比如我有一个列表，它有一堆query筛选项，这时候你就能deep watch它，只有任何一个筛序项改变的时候，就自动请求新的数据。或者你可以deep watch一个 form 表单，当任何一个字段内容发生变化的时候，你就帮它做自动保存等等。<br>:::</p>\n<h2 id=\"表单参数处理\"><a href=\"#表单参数处理\" class=\"headerlink\" title=\"表单参数处理\"></a>表单参数处理</h2><h3 id=\"Computed-的-get-和-set\"><a href=\"#Computed-的-get-和-set\" class=\"headerlink\" title=\"Computed 的 get 和 set\"></a>Computed 的 get 和 set</h3><p>假如表单填写的值需要特殊处理后再传给后端：<br>当然我们可以直接在访问接口时处理参数，但是参数很多，很多都需要处理会导致访问接口都函数变得过于臃肿。这时可以使用 <code>Computed 的 get 和 set</code></p>\n<p>::: warning<br>下面只是一个示例！<br>:::</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">el-form</span> <span class=\"attr\">:model</span>=<span class=\"string\">&quot;formModel&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">el-form-item</span> <span class=\"attr\">prop</span>=<span class=\"string\">&quot;pwd&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">el-input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;pwd&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">el-input</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">el-form-item</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">el-form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">const</span> crypt = &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    encrypt(word) &#123;&#125;,   <span class=\"comment\">// 加密</span></span></span><br><span class=\"line\"><span class=\"javascript\">    decrypt(word) &#123;&#125;    <span class=\"comment\">// 解密</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\">    data() &#123;</span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\">            formModel: &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    computed: &#123;</span><br><span class=\"line\">        pwd: &#123;</span><br><span class=\"line\">            get() &#123;</span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">return</span> crypt.decrypt(<span class=\"built_in\">this</span>.formModel.pwd)</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            set(val) &#123;</span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">this</span>.formModel.pwd = crypt.encrypt(val)</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Object-freeze\"><a href=\"#Object-freeze\" class=\"headerlink\" title=\"Object.freeze\"></a>Object.freeze</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 组件通讯方面</span><br><span class=\"line\"></span><br><span class=\"line\">### props和事件</span><br><span class=\"line\">- 没有Typescript为了支持类型检查props一定要写成对象形式：</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;js</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; props: [&#39;val&#39;], &#x2F;&#x2F; 不建议这样使用</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">        val: &#123;</span><br><span class=\"line\">            type: String,</span><br><span class=\"line\">            required: true,</span><br><span class=\"line\">            default: &#39;&#39;,</span><br><span class=\"line\">            validator: value &#x3D;&gt; new Set([&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;]).has(value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>props是父组件传给自组件的，子组件永远不要尝试直接去修改它，应该使用事件的方式:</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\">&lt;the-component @event-name=<span class=\"string\">&quot;eventHandler&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子组件</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;event-name&#x27;</span><span class=\"comment\">/*, some arguments of eventHandler*/</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>attrs: 获取子传父中未在 props 定义的值  <ul>\n<li>场景1：如果子组件需要大量来自父组件的值，那么就需要在自组件定义大量props，此时可以考虑使用attrs。  </li>\n</ul>\n  <em>但是为了降低子组件对父的耦合还是不建议这样使用。</em><ul>\n<li>场景2: 当我们要封装第三方组件时，第三方组件可能拥有很多自定义的属性和事件，此时我们添加自己的属性和事件的同时还要保证被封装组件的属性和事件被暴露出去，例如：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">third-part-component</span> <span class=\"attr\">v-bind</span>=<span class=\"string\">&quot;$attrs&quot;</span> <span class=\"attr\">v-on</span>=<span class=\"string\">&quot;$listeners&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        inheritAttrs: <span class=\"literal\">false</span>, <span class=\"comment\">// 下面会说</span></span></span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            handler() &#123;</span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">// 自定义事件</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;event-name&#x27;</span>, ...)</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// sth</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>inheritAttrs <a href=\"https://cn.vuejs.org/v2/api/#inheritAttrs\">官方文档</a><br>默认为<code>true</code>，此时父组件传递所有的属性都会被应用到子组件的根节点上。改为<code>false</code>可去掉这一默认行为。</li>\n</ul>\n<h3 id=\"root\"><a href=\"#root\" class=\"headerlink\" title=\"$root\"></a>$root</h3><p>整棵组件树的根实例</p>\n<h3 id=\"sync\"><a href=\"#sync\" class=\"headerlink\" title=\".sync\"></a>.sync</h3><p>实现双向绑定的语法糖，<a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6\">官方文档</a></p>\n<h3 id=\"v-slot\"><a href=\"#v-slot\" class=\"headerlink\" title=\"v-slot\"></a>v-slot</h3><p>2.6.0 新增 1.slot,slot-cope,scope 在 2.6.0 中都被废弃,但未被移除 2.作用就是将父组件的 template 传入子组件 3.插槽分类: A.匿名插槽(也叫默认插槽): 没有命名,有且只有一个;<a href=\"https://cn.vuejs.org/v2/api/#v-slot\">官方文档</a></p>\n<h3 id=\"路由传参\"><a href=\"#路由传参\" class=\"headerlink\" title=\"路由传参\"></a>路由传参</h3><p>方案一 <code>path/:id</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 路由定义</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  path: <span class=\"string\">&#x27;/describe/:id&#x27;</span>,</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;Describe&#x27;</span>,</span><br><span class=\"line\">  component: Describe</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 页面传参</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">`/describe/<span class=\"subst\">$&#123;id&#125;</span>`</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 页面获取</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$route.params.id</span><br></pre></td></tr></table></figure>\n\n<p>方案一 <code>params</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 路由定义</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  path: <span class=\"string\">&#x27;/describe&#x27;</span>,</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;Describe&#x27;</span>,</span><br><span class=\"line\">  omponent: Describe</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 页面传参</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;Describe&#x27;</span>,</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    id: id</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 页面获取</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$route.params.id</span><br></pre></td></tr></table></figure>\n\n<p>方案三 <code>query</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 路由定义</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  path: <span class=\"string\">&#x27;/describe&#x27;</span>,</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;Describe&#x27;</span>,</span><br><span class=\"line\">  component: Describe</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 页面传参</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">&#x27;/describe&#x27;</span>,</span><br><span class=\"line\">    query: &#123;</span><br><span class=\"line\">      id: id</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// /describe?id=123</span></span><br></pre></td></tr></table></figure>\n\n<p>三种方案对比 方案二参数不会拼接在路由后面,页面刷新参数会丢失 方案一和三参数拼接在后面,丑,而且暴露了信息</p>\n<h3 id=\"Vue-observable\"><a href=\"#Vue-observable\" class=\"headerlink\" title=\"Vue.observable\"></a>Vue.observable</h3><p>2.6.0 新增<br>用法:让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象;<br>返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新;<br>也可以作为最小化的跨组件状态存储器，用于简单的场景。<br>通讯原理实质上是利用Vue.observable实现一个简易的 vuex:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// store.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> store = Vue.observable(&#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> mutations = &#123;</span><br><span class=\"line\">  setCount (count) &#123;</span><br><span class=\"line\">    store.count = count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;bookNum&quot;</span>&gt;</span>数 量<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;setCount(count+1)&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;setCount(count-1)&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">import</span> &#123; store, mutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;store.js&#x27;</span> <span class=\"comment\">// Vue2.6新增API Observable</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">&#x27;Add&#x27;</span>,</span></span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    count () &#123;</span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> store.count</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    setCount: mutations.setCount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"render-函数\"><a href=\"#render-函数\" class=\"headerlink\" title=\"render 函数\"></a>render 函数</h2><p>场景:有些代码在 template 里面写会重复很多,所以这个时候 render 函数就有作用啦<a href=\"https://cn.vuejs.org/v2/guide/render-function.html\">官方文档</a></p>\n<h2 id=\"异步组件\"><a href=\"#异步组件\" class=\"headerlink\" title=\"异步组件\"></a>异步组件</h2><p>场景:项目过大就会导致加载缓慢,所以异步组件实现按需加载就是必须要做的事啦 1.异步注册组件 3种方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂函数执行 resolve 回调</span></span><br><span class=\"line\">Vue.component(<span class=\"string\">&#x27;async-webpack-example&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这个特殊的 `require` 语法将会告诉 webpack</span></span><br><span class=\"line\">  <span class=\"comment\">// 自动将你的构建代码切割成多个包, 这些包</span></span><br><span class=\"line\">  <span class=\"comment\">// 会通过 Ajax 请求加载</span></span><br><span class=\"line\">  <span class=\"built_in\">require</span>([<span class=\"string\">&#x27;./my-async-component&#x27;</span>], resolve)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂函数返回 Promise</span></span><br><span class=\"line\">Vue.component(</span><br><span class=\"line\">  <span class=\"string\">&#x27;async-webpack-example&#x27;</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 这个 `import` 函数会返回一个 `Promise` 对象。</span></span><br><span class=\"line\">  () =&gt; <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./my-async-component&#x27;</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂函数返回一个配置化组件对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> AsyncComponent = <span class=\"function\">() =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class=\"line\">  component: <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./MyComponent.vue&#x27;</span>),</span><br><span class=\"line\">  <span class=\"comment\">// 异步组件加载时使用的组件</span></span><br><span class=\"line\">  loading: LoadingComponent,</span><br><span class=\"line\">  <span class=\"comment\">// 加载失败时使用的组件</span></span><br><span class=\"line\">  error: ErrorComponent,</span><br><span class=\"line\">  <span class=\"comment\">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class=\"line\">  delay: <span class=\"number\">200</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class=\"line\">  <span class=\"comment\">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class=\"line\">  timeout: <span class=\"number\">3000</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"路由按需加载\"><a href=\"#路由按需加载\" class=\"headerlink\" title=\"路由按需加载\"></a>路由按需加载</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  path:<span class=\"string\">&#x27;/&#x27;</span>,</span><br><span class=\"line\">  name:<span class=\"string\">&#x27;home&#x27;</span>,</span><br><span class=\"line\">  components:<span class=\"function\">()=&gt;</span><span class=\"keyword\">import</span>(<span class=\"string\">&#x27;@/components/home&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动态组件\"><a href=\"#动态组件\" class=\"headerlink\" title=\"动态组件\"></a>动态组件</h2><p>场景:做一个 tab 切换时就会涉及到组件动态加载</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">&quot;currentTabComponent&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--优化--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">&quot;currentTabComponent&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"递归组件\"><a href=\"#递归组件\" class=\"headerlink\" title=\"递归组件\"></a>递归组件</h2><p>场景:如果开发一个 tree 组件,里面层级是根据后台数据决定的,这个时候就需要用到递归组件<br>递归组件必须设置name和递归终止条件，<code>v-if=终止条件</code></p>\n<h2 id=\"函数式组件\"><a href=\"#函数式组件\" class=\"headerlink\" title=\"函数式组件\"></a>函数式组件</h2><p>无状态，无法实例化，只是一个函数，开销低，<a href=\"https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6\">官方文档</a></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">functional</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(item,index) in props.arr&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Vue-extend\"><a href=\"#Vue-extend\" class=\"headerlink\" title=\"Vue.extend\"></a>Vue.extend</h2><p>场景:vue 组件中有些需要将一些元素挂载到元素上,这个时候 extend 就起到作用了 是构造一个组件的语法器 写法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Modal = Vue.extend(&#123;</span><br><span class=\"line\">    template: <span class=\"string\">&#x27;&lt;div&gt;This is a modal&lt;/div&gt;&#x27;</span>,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">        title: &#123;</span><br><span class=\"line\">            type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"string\">&#x27;标题&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 挂载</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Modal(&#123;</span><br><span class=\"line\">    propsData: &#123;</span><br><span class=\"line\">        title: <span class=\"string\">&#x27;Modal&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).$mount(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>通过<code>Vue.use(Plugin)</code>安装注册插件，通过安装插件可以添加全局资源（例如：组件等），添加Vue实例方法<a href=\"https://cn.vuejs.org/v2/guide/plugins.html\">官方文档</a></p>\n<h2 id=\"Vue-nextTick\"><a href=\"#Vue-nextTick\" class=\"headerlink\" title=\"Vue.nextTick\"></a>Vue.nextTick</h2><p>组件的<code>mounted</code>生命周期dom并未渲染完毕可以通过：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    mounted() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.$nextTick(<span class=\"function\">() =&gt;</span> 获取更新后的dom)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Vue-set\"><a href=\"#Vue-set\" class=\"headerlink\" title=\"Vue.set()\"></a>Vue.set()</h2><p>场景:当你利用索引直接设置一个数组项时或你修改数组的长度时,由于 Object.defineprototype()方法限制,数据不响应式更新 不过vue.3.x 将利用 proxy 这个问题将得到解决 解决方案:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 利用 set</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$set(arr,index,item)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 利用数组 push(),splice()</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"v-pre\"><a href=\"#v-pre\" class=\"headerlink\" title=\"v-pre\"></a>v-pre</h2><p>场景:vue 是响应式系统,但是有些静态的标签不需要多次编译,这样可以节省性能</p>\n<h2 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h2><p>场景:在网速慢的情况下,在使用vue绑定数据的时候，渲染页面时会出现变量闪烁<br>用法:这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕</p>\n<h2 id=\"v-once\"><a href=\"#v-once\" class=\"headerlink\" title=\"v-once\"></a>v-once</h2><p>v-once 和 v-pre 的区别: v-once只渲染一次；v-pre不编译,原样输出</p>\n<h2 id=\"vue组件的deep-属性\"><a href=\"#vue组件的deep-属性\" class=\"headerlink\" title=\".vue组件的deep 属性\"></a>.vue组件的deep 属性</h2><p>有的时候我们想要修改某组件内部的样式，但是由于<code>&lt;style scoped&gt;</code>加了<code>scoped</code>导致这里写的选择器上都加上了<code>[data-039c5b43]</code>类似的自定义属性，例如：  </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;less&quot;</span> <span class=\"attr\">scoped</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-class\">.container</span> <span class=\"selector-class\">.red</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span> &#125;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 编译后 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/css&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-class\">.container</span><span class=\"selector-attr\">[data-039c5b43]</span> <span class=\"selector-class\">.red</span><span class=\"selector-attr\">[data-039c5b43]</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span> &#125;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然而组件内部对应的标签上并不存在<code>.red[data-039c5b43]</code>选择器，因此无法修改到组件内部的样式。<br>因此官方提供了deep属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 上面样式加一个 /deep/ --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;less&quot;</span> <span class=\"attr\">scoped</span>&gt;</span></span><br><span class=\"line\">    .container /deep/ .red &#123; color: #f00 &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 编译后 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/css&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-class\">.container</span><span class=\"selector-attr\">[data-039c5b43]</span> <span class=\"selector-class\">.red</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span> &#125;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["Vue"]},{"title":"pwa-guide","url":"https://niannings.github.io/2019/10/14/pwa-guide/","content":"<h1 id=\"PWA初探\"><a href=\"#PWA初探\" class=\"headerlink\" title=\"PWA初探\"></a>PWA初探</h1><p>[TOC]</p>\n<h2 id=\"PWA是什么\"><a href=\"#PWA是什么\" class=\"headerlink\" title=\"PWA是什么?\"></a>PWA是什么?</h2><blockquote>\n<p>PWA（Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。这些应用无处不在、功能丰富，使其具有与原生应用相同的用户体验优势。</p>\n</blockquote>\n<h2 id=\"PWA的优势-Progressive-web-app-advantages\"><a href=\"#PWA的优势-Progressive-web-app-advantages\" class=\"headerlink\" title=\"PWA的优势(Progressive web app advantages)\"></a>PWA的优势(Progressive web app advantages)</h2><blockquote>\n<p>PWA 是可被发现、易安装、可链接、独立于网络、渐进式、可重用、响应性和安全的。</p>\n</blockquote>\n<ul>\n<li>什么是渐进式（Progressive）？<br>可以用<strong>渐进增强</strong>来描述，就是要为现代功能强大的浏览器提供最优质的体验和最炫酷的效果，同时也能为较弱的浏览器提供还能接受的体验效果。</li>\n</ul>\n<p>上面的内容都可以在<a href=\"https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Advantages\">MDN相关文档</a>找到详细介绍。</p>\n<h2 id=\"Web-App-Manifest\"><a href=\"#Web-App-Manifest\" class=\"headerlink\" title=\"Web App Manifest\"></a>Web App Manifest</h2><p>详情参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Manifest\">MDN Web App Manifest</a></p>\n<h2 id=\"PWA是如何独立于网络的\"><a href=\"#PWA是如何独立于网络的\" class=\"headerlink\" title=\"PWA是如何独立于网络的\"></a>PWA是如何独立于网络的</h2><p>详情参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API\">MDN Service Worker API</a></p>\n<blockquote>\n<p>Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。</p>\n</blockquote>\n<ul>\n<li><p>特点</p>\n<ul>\n<li>细粒度地缓存资源</li>\n<li>不会阻塞主线程：Service worker运行在worker上下文，因此它不能访问DOM。相对于驱动应用的主JavaScript线程，它运行在其他线程中，所以不会造成阻塞。它设计为完全异步，同步API（如XHR和localStorage）不能在service worker中使用。</li>\n<li>为了安全，只能是HTTPS</li>\n</ul>\n</li>\n<li><p>注册</p>\n<blockquote>\n<p>使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer/register\">ServiceWorkerContainer.register()</a> 方法首次注册service worker。如果注册成功，service worker就会被下载到客户端并尝试安装或激活（见下文），这将作用于整个域内用户可访问的URL，或者其特定子集。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ul>\n<li>service worker 的基本架构是什么？</li>\n<li>怎么注册一个 service worker？</li>\n<li>一个新  service worker 的 install 及 activation 过程？</li>\n<li>怎么更新 service worker？</li>\n<li>它的缓存控制和自定义响应？</li>\n</ul>\n<p>详情参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers\">MDN 使用 Service Workers</a></p>\n<ol>\n<li>请求和响应流只能被读取一次</li>\n</ol>\n<h4 id=\"fetch事件\"><a href=\"#fetch事件\" class=\"headerlink\" title=\"fetch事件\"></a>fetch事件</h4><blockquote>\n<p>每次任何被 service worker 控制的资源被请求到时，都会触发 fetch 事件，这些资源包括了指定的 scope 内的文档，和这些文档内引用的其他任何资源</p>\n</blockquote>\n<p>一个来自MDN的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">&#x27;fetch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  event.respondWith(</span><br><span class=\"line\">    <span class=\"comment\">// 尝试读取缓存</span></span><br><span class=\"line\">    caches.match(event.request).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resp</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 读取到了直接返回，否则发起网络请求</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> resp || fetch(event.request).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> caches.open(<span class=\"string\">&#x27;v1&#x27;</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将response 拷贝并缓存</span></span><br><span class=\"line\">          cache.put(event.request, response.clone());</span><br><span class=\"line\">          <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当请求没有匹配到缓存中的任何资源的时候，以及网络不可用的时候，</span></span><br><span class=\"line\">      <span class=\"comment\">// 我们的请求依然会失败</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> caches.match(<span class=\"string\">&#x27;/sw-test/gallery/myLittleVader.jpg&#x27;</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"版本控制-更新你的service-worker\"><a href=\"#版本控制-更新你的service-worker\" class=\"headerlink\" title=\"版本控制(更新你的service worker)\"></a>版本控制(更新你的service worker)</h4><blockquote>\n<p>如果你的 service worker 已经被安装，但是刷新页面时有一个新版本的可用，新版的 service worker 会在后台安装，但是还没激活。当不再有任何已加载的页面在使用旧版的 service worker 的时候，新版本才会激活。一旦再也没有更多的这样已加载的页面，新的 service worker 就会被激活。</p>\n</blockquote>\n<p>修改<code>install</code>事件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  event.waitUntil(</span><br><span class=\"line\">    caches.open(<span class=\"string\">&#x27;v2&#x27;</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache.addAll([</span><br><span class=\"line\">        <span class=\"string\">&#x27;/sw-test/&#x27;</span>,</span><br><span class=\"line\">        …</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// include other new resources for the new version...</span></span><br><span class=\"line\">      ]);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>当安装发生的时候，前一个版本依然在响应请求，新的版本正在后台安装，我们调用了一个新的缓存 v2，所以前一个 v1 版本的缓存不会被扰乱。</p>\n<p>当没有页面在使用当前的版本的时候，这个新的 service worker 就会激活并开始响应请求。</p>\n<h4 id=\"清理旧缓存\"><a href=\"#清理旧缓存\" class=\"headerlink\" title=\"清理旧缓存\"></a>清理旧缓存</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">&#x27;activate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cacheWhitelist = [<span class=\"string\">&#x27;v2&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 传给 waitUntil() 的 promise 会阻塞其他的事件，直到它完成。</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以你可以确保你的清理操作会在你的的第一次 fetch 事件之前会完成。</span></span><br><span class=\"line\">  event.waitUntil(</span><br><span class=\"line\">    caches.keys().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">keyList</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(keyList.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cacheWhitelist.indexOf(key) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> caches.delete(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"一个来自MDN的完整service-worker例子\"><a href=\"#一个来自MDN的完整service-worker例子\" class=\"headerlink\" title=\"一个来自MDN的完整service worker例子\"></a>一个来自MDN的完整service worker例子</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sw.js</span></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  event.waitUntil(</span><br><span class=\"line\">    caches.open(<span class=\"string\">&#x27;v1&#x27;</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache.addAll([</span><br><span class=\"line\">        <span class=\"string\">&#x27;/sw-test/&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;/sw-test/index.html&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;/sw-test/style.css&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;/sw-test/app.js&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;/sw-test/image-list.js&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;/sw-test/star-wars-logo.jpg&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;/sw-test/gallery/bountyHunters.jpg&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;/sw-test/gallery/myLittleVader.jpg&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;/sw-test/gallery/snowTroopers.jpg&#x27;</span></span><br><span class=\"line\">      ]);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">&#x27;fetch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  event.respondWith(caches.match(event.request).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// caches.match() always resolves</span></span><br><span class=\"line\">    <span class=\"comment\">// but in case of success response will have value</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fetch(event.request).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// response may be used only once</span></span><br><span class=\"line\">        <span class=\"comment\">// we need to save clone to put one copy in cache</span></span><br><span class=\"line\">        <span class=\"comment\">// and serve second one</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> responseClone = response.clone();</span><br><span class=\"line\">        </span><br><span class=\"line\">        caches.open(<span class=\"string\">&#x27;v1&#x27;</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">          cache.put(event.request, responseClone);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">      &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> caches.match(<span class=\"string\">&#x27;/sw-test/gallery/myLittleVader.jpg&#x27;</span>);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"下面我们尝试编写一个sw-js并观察它的运行情况\"><a href=\"#下面我们尝试编写一个sw-js并观察它的运行情况\" class=\"headerlink\" title=\"下面我们尝试编写一个sw.js并观察它的运行情况\"></a>下面我们尝试编写一个sw.js并观察它的运行情况</h2><p>查看我的<a href=\"http://note.youdao.com/noteshare?id=22653cbf313e22732143a578fe771837\">例子</a></p>\n<h1 id=\"让我们的PWA应用程序可以安装\"><a href=\"#让我们的PWA应用程序可以安装\" class=\"headerlink\" title=\"让我们的PWA应用程序可以安装\"></a>让我们的PWA应用程序可以安装</h1><p>详情参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Installable_PWAs\">MDN</a></p>\n<p>通过前面的工作我们已经可以实现web的离线访问了，但是离原生的app还是有些差距：安装到本地、更容易访问、全屏运行、没有浏览器界面，最终看起来更像一个本地应用。</p>\n<p>如何做到这些？</p>\n<h2 id=\"要求：\"><a href=\"#要求：\" class=\"headerlink\" title=\"要求：\"></a>要求：</h2><ul>\n<li>一份网页清单，填好 正确的字段</li>\n<li>网站的域必须是安全（HTTPS）的</li>\n<li>一个本设备上代表应用的图标</li>\n<li>一个注册好的service worker，可以让应用离线工作（这仅对于安卓设备上的Chrome浏览器是必需的）</li>\n</ul>\n<h3 id=\"一份清单-Manifest\"><a href=\"#一份清单-Manifest\" class=\"headerlink\" title=\"一份清单(Manifest)\"></a>一份清单(Manifest)</h3><p>参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Manifest\">MDN</a></p>\n<p>把它放到head标签中</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;manifest&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;js13kpwa.webmanifest&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：过去有一些常用的扩展名用于清单：manifest.webapp 在Firefox OS应用清单中很流行，许多人使用manifest.json作为网页清单因为内容是JSON格式的。但是，.webmanifest 扩展名是在W3C清单规范 中显示指定的，所有应该坚持这种做法。</p>\n</blockquote>\n<p>一份基本的清单：<code>js13kpwa.webmanifest</code></p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;js13kGames Progressive Web App&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;short_name&quot;</span>: <span class=\"string\">&quot;js13kPWA&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;description&quot;</span>: <span class=\"string\">&quot;Progressive Web App that lists games submitted to the A-Frame category in the js13kGames 2017 competition.&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;icons&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;src&quot;</span>: <span class=\"string\">&quot;icons/icon-32.png&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;sizes&quot;</span>: <span class=\"string\">&quot;32x32&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;image/png&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;src&quot;</span>: <span class=\"string\">&quot;icons/icon-512.png&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;sizes&quot;</span>: <span class=\"string\">&quot;512x512&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;image/png&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">&quot;start_url&quot;</span>: <span class=\"string\">&quot;/pwa-examples/js13kpwa/index.html&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;display&quot;</span>: <span class=\"string\">&quot;fullscreen&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;theme_color&quot;</span>: <span class=\"string\">&quot;#B12A34&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;background_color&quot;</span>: <span class=\"string\">&quot;#B12A34&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后将我们的项目部署到github，用手机打开试试</p>\n<p>可以打开<a href=\"https://esop-fed.github.io/ani-css/\">https://esop-fed.github.io/ani-css/</a>看看。</p>\n","categories":[],"tags":["PWA"]},{"title":":2019-:10-:12-:diary.md","url":"https://niannings.github.io/2019/10/12/2019-10-12-diary-md/","content":"","categories":[],"tags":["Diary"]},{"title":"使用Hexo+GitHub搭建静态博客教程","url":"https://niannings.github.io/2019/10/12/hexo-blog-building/","content":"<p>使用<a href=\"https://hexo.io/zh-cn/docs/\">Hexo</a>搭建静态博客</p>\n<ul>\n<li>依赖：<ul>\n<li>Nodejs</li>\n<li>Git</li>\n<li>GitHub</li>\n</ul>\n</li>\n</ul>\n<p><strong>如果不会yml文件，可以狠狠的<a href=\"http://www.ruanyifeng.com/blog/2016/07/yaml.html\">点这里</a></strong></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install -g hexo-cli</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"comment\"># 或者</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> yarn global add hexo-cli</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo init &lt;folder&gt;</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> &lt;folder&gt;</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install</span></span><br></pre></td></tr></table></figure>\n<p>新建完成后，指定文件夹的目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>_config.yml是网站的<a href=\"https://hexo.io/zh-cn/docs/configuration\">配置文件</a></p>\n</li>\n<li><p>scaffolds: 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>\n</li>\n<li><p>source<br>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>\n</li>\n<li><p>themes<br>主题 文件夹。Hexo 会根据主题来生成静态页面。</p>\n</li>\n</ul>\n<h2 id=\"布局（Layout）\"><a href=\"#布局（Layout）\" class=\"headerlink\" title=\"布局（Layout）\"></a>布局（Layout）</h2><table>\n<thead>\n<tr>\n<th>布局</th>\n<th>路径</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>post</td>\n<td>source/_posts</td>\n</tr>\n<tr>\n<td>page</td>\n<td>source</td>\n</tr>\n<tr>\n<td>draft</td>\n<td>source/_draft</td>\n</tr>\n</tbody></table>\n<h2 id=\"文件名称\"><a href=\"#文件名称\" class=\"headerlink\" title=\"文件名称\"></a>文件名称</h2><figure class=\"highlight plain\"><figcaption><span>默认以标题做为文件名称，但您可编辑 ```new_post_name``` 参数来改变默认的文件名称，举例来说，设为 ```:year-:month-:day-:title.md``` 可让您更方便的通过日期来管理文章。</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">| 变量 |  描述 |</span><br><span class=\"line\">|---|---|</span><br><span class=\"line\">| :title | 标题（小写，空格将会被替换为短杠）|</span><br><span class=\"line\">| :year | 建立的年份，比如， 2015 |</span><br><span class=\"line\">| :month | 建立的月份（有前导零），比如， 04 |</span><br><span class=\"line\">| :i_month | 建立的月份（无前导零），比如， 4 |</span><br><span class=\"line\">| :day | 建立的日期（有前导零），比如， 07 |</span><br><span class=\"line\">| :i_day | 建立的日期（无前导零），比如， 7 |</span><br><span class=\"line\"></span><br><span class=\"line\">## 草稿</span><br><span class=\"line\"></span><br><span class=\"line\">刚刚提到了 &#96;&#96;&#96;Hexo&#96;&#96;&#96; 的一种特殊布局：&#96;&#96;&#96;draft&#96;&#96;&#96;，这种布局在建立时会被保存到 &#96;&#96;&#96;source&#x2F;_drafts&#96;&#96;&#96; 文件夹，您可通过 &#96;&#96;&#96;publish&#96;&#96;&#96; 命令将草稿移动到 &#96;&#96;&#96;source&#x2F;_posts&#96;&#96;&#96; 文件夹，该命令的使用方式与 &#96;&#96;&#96;new&#96;&#96;&#96; 十分类似，您也可在命令中指定 &#96;&#96;&#96;layout&#96;&#96;&#96; 来指定布局。</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96; shell</span><br><span class=\"line\">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模版（Scaffold）\"><a href=\"#模版（Scaffold）\" class=\"headerlink\" title=\"模版（Scaffold）\"></a>模版（Scaffold）</h2><p>在新建文章时，<code>Hexo</code> 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo new photo <span class=\"string\">&quot;My Gallery&quot;</span> <span class=\"comment\"># photo是模版文件名称</span></span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>layout</td>\n<td>布局</td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题</td>\n</tr>\n<tr>\n<td>date</td>\n<td>文件建立日期</td>\n</tr>\n</tbody></table>\n<h2 id=\"Cli\"><a href=\"#Cli\" class=\"headerlink\" title=\"Cli\"></a>Cli</h2><p>新建页面（page）、文章（post）、草稿（draft）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo new [layout] &lt;title&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"开始写作\"><a href=\"#开始写作\" class=\"headerlink\" title=\"开始写作\"></a>开始写作</h1><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo new post my-post <span class=\"comment\"># /source/_posts/my-post.md</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"comment\"># 为了更好的归档可以像下面那样</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo new post :2019-:10-:12-:diary.md</span></span><br></pre></td></tr></table></figure>\n<p>生成的文件长这样：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">&#x27;:2019-:10-:12-:diary.md&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Diary</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2019-10-12 11:25:29</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n<p>两个三横线中间是什么呢？可以狠狠的<a href=\"https://jekyllrb.com/docs/front-matter/\">点这里</a></p>\n<h3 id=\"以下是预先定义的参数\"><a href=\"#以下是预先定义的参数\" class=\"headerlink\" title=\"以下是预先定义的参数:\"></a>以下是预先定义的参数:</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>layout</td>\n<td>布局</td>\n<td></td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题</td>\n<td></td>\n</tr>\n<tr>\n<td>date</td>\n<td>建立日期</td>\n<td>文件建立日期</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>更新日期</td>\n<td>文件更新日期</td>\n</tr>\n<tr>\n<td>comments</td>\n<td>开启文章的评论功能</td>\n<td>true</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>标签（不适用于分页）</td>\n<td></td>\n</tr>\n<tr>\n<td>categories</td>\n<td>分类（不适用于分页）</td>\n<td></td>\n</tr>\n<tr>\n<td>permalink</td>\n<td>覆盖文章网址</td>\n<td></td>\n</tr>\n<tr>\n<td>keywords</td>\n<td>仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"分类和标签\"><a href=\"#分类和标签\" class=\"headerlink\" title=\"分类和标签\"></a>分类和标签</h3><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">categories:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">Diary</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">PS3</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">Games</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态资源\"><a href=\"#静态资源\" class=\"headerlink\" title=\"静态资源\"></a>静态资源</h2><h3 id=\"少量资源\"><a href=\"#少量资源\" class=\"headerlink\" title=\"少量资源\"></a>少量资源</h3><p>图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 <img src=\"/images/image.jpg\"> 的方法访问它们</p>\n<h3 id=\"文章资源文件夹\"><a href=\"#文章资源文件夹\" class=\"headerlink\" title=\"文章资源文件夹\"></a>文章资源文件夹</h3><p>可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">post_asset_folder:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>当资源文件管理功能打开后，<code>Hexo</code>将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>\n<h2 id=\"部署到GitHub\"><a href=\"#部署到GitHub\" class=\"headerlink\" title=\"部署到GitHub\"></a>部署到GitHub</h2><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p>\n<ul>\n<li>首先安装部署工具</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改部署配置<code>_config.yml</code></li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">&lt;repository</span> <span class=\"string\">url&gt;</span> <span class=\"comment\"># 远程仓库地址</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> [<span class=\"string\">branch</span>] <span class=\"comment\"># 要发布到哪个分支</span></span><br><span class=\"line\">  <span class=\"attr\">message:</span> [<span class=\"string\">message</span>] <span class=\"comment\"># commit message</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>发布</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo deploy</span></span><br></pre></td></tr></table></figure>\n","categories":["其他"],"tags":["Hexo"]},{"title":"react-hooks","url":"https://niannings.github.io/2019/10/11/react-hooks/","content":"<p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明一个新的叫做 “count” 的 state 变量</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> setCount(count + <span class=\"number\">1</span>)&#125;&gt;</span><br><span class=\"line\">        Click me</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["web前端"],"tags":["react","hooks"]},{"title":"home","url":"https://niannings.github.io/2019/10/11/home/","content":"","categories":[],"tags":[]},{"title":"关于","url":"https://niannings.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"https://niannings.github.io/css/personal-style.css","content":"/* html, body {\n    width: 100%;\n    height: 100%;\n}\n\nbody::after {\n    content: ' ';\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    z-index: -1;\n    background: url(https://avatars1.githubusercontent.com/u/37898800?s=460&v=4) no-repeat;\n    background-size: cover;\n    background-position: 0 center;\n    filter: blur(80px);\n} */\n\n/* .content-home.text-center::before {\n    position: absolute;\n    content: ' ';\n    left: 40%;\n    right: 40%;\n    height: 300px;\n    background-color: rgba(255, 255, 255, 0.6);\n    border-radius: 50%;\n    filter: blur(10px);\n} */\n\n/* .content-home.text-center .slogan {\n    color: rgb(206, 206, 206);\n}\n.text-center.nav .item a {\n    color: rgb(206, 206, 206);\n}\n */\n","categories":[],"tags":[]},{"title":"搜索","url":"https://niannings.github.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"https://niannings.github.io/project/index.html","content":"","categories":[],"tags":[]},{"title":"标签","url":"https://niannings.github.io/tags/index.html","content":"","categories":[],"tags":[]},{"title":"友链","url":"https://niannings.github.io/friends/index.html","content":"","categories":[],"tags":[]},{"title":"contact","url":"https://niannings.github.io/contact/index.html","content":"","categories":[],"tags":[]},{"title":"文章分类","url":"https://niannings.github.io/categories/index.html","content":"","categories":[],"tags":[]}]